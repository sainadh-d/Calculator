{"version":3,"sources":["calculator/handlers.cljs"],"mappings":";AASA,AAAA,AAAMA,AAAeC,AAAaC;AAAlC,AACE,AAAMC,AAAW,AAAA,AAAA,AAAAC,AAAWH;AACtBI,AAAW,AAAA,AAAA,AAAAD,AAAaH;AAD9B,AAEE,AAAAK,AAAMJ;AAAN,AAAA,AAAAI;AAAA;AACO,AAAA,AAAQ,AAACC,AAAEJ,AAAWK;AACpB,AAAA,AAACC,AAAMR,AAAaS,AAAe,AAACC,AAAgBR;;AACpD,AAACM,AAAMG,AAAmBC;;;;AAHnC;AAIO,AACE,AAAA,AAAA,AAACJ,AAAMR,AAAaS;;AACpB,AAACD,AAAMG,AAAmBE,AAAKX;;AAC/B,AAAA,AAACM,AAAMR,AAAaS,AAAe,AAACK,AAAeZ;;;;AAE1D,AAAI,AAAAa,AACE,AAAA,AAACT,AAAEJ;AADL,AAAA,AAAAa;AAAAA;;AAAA,AAAAA,AAEE,AAACT,AAAEJ,AAAWK;AAFhB,AAAA,AAAAQ;AAAAA;;AAGE,AAAK,AAACC,AAAaf;AAAOG;;AAA1B;;;;;AACJ,AACE,AAAA,AAAA,AAACI,AAAMR,AAAaS;;AACpB,AAAA,AAACD,AAAMR,AAAaS,AAAeR;;AACrC,AACE,AAAA,AAAA,AAACO,AAAMR,AAAaS;;AACpB,AAAA,AAACD,AAAMR,AAAaS,AAAe,AAAKP,AAAWD;;;;;AAG7D,AAAA,AAAMgB,AAAmBC;AAAzB,AAAA;AAIE,AAACnB,AAAcoB,AAAa,AAAA,AAAID;;AAElC,AAAA,AAAME,AAA0BF;AAAhC,AACE,AAAA,AAAA,AAACV,AAAMW,AAAaV;;AACpB,AAAA,AAACD,AAAMW,AAAaV,AAAe,AAAA,AAAIS","names":["calculator.handlers/update-state!","screen-state","value","expression","cljs.core/deref","evaluated","G__27778","cljs.core._EQ_","calculator.state/default-display-value","cljs.core.swap_BANG_","cljs.core/assoc","calculator.utils/backspace","calculator.state/expression-history","cljs.core/rest","cljs.core/conj","calculator.utils/evaluate","or__4160__auto__","calculator.utils/is-num","calculator.handlers/key-click-handler","event","calculator.state/screen-state","calculator.handlers/expression-click-handler"],"sourcesContent":["(ns calculator.handlers\n  (:require [calculator.state :refer [expression-history screen-state default-display-value]]\n            [calculator.utils :as utils]))\n\n;; Note:\n;; If expression is evaluated and a new number is pressed then it will be the start of a new expresssion\n;; But if an operator is pressed, then the old expression will continue\n;; This logic is handled using :evaluated key in screen-state atom\n\n(defn update-state! [screen-state value]\n  (let [expression (:display @screen-state)\n        evaluated  (:evaluated @screen-state)]\n    (case value\n      \"\u2190\"  (if-not (= expression default-display-value)\n             (swap! screen-state assoc :display (utils/backspace expression))\n             (swap! expression-history rest))\n      \"=\"  (do\n             (swap! screen-state assoc :evaluated true)\n             (swap! expression-history conj expression)\n             (swap! screen-state assoc :display (utils/evaluate expression)))\n      ;; default case\n      (if (or\n            (= expression \"Error\")\n            (= expression default-display-value)\n            (and (utils/is-num value) evaluated))\n        (do\n          (swap! screen-state assoc :evaluated false)\n          (swap! screen-state assoc :display value))\n        (do\n          (swap! screen-state assoc :evaluated false)\n          (swap! screen-state assoc :display (str expression value)))))))\n\n\n(defn key-click-handler [event]\n  \"Callback function which takes the click event and updates the state\"\n  ;; (.. event -target -value) is same as (-> event .-target .-value) is same as (.-value (.-target event)\n  ;; JS obj properties are accessed using .-property\n  (update-state! screen-state (.. event -target -innerText)))\n\n(defn expression-click-handler [event]\n  (swap! screen-state assoc :evaluated false)\n  (swap! screen-state assoc :display (.. event -target -innerText)))\n"]}